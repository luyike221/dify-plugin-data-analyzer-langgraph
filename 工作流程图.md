# 项目工作流程图

## 1. 整体架构流程

```mermaid
graph TB
    Start([用户上传Excel文件]) --> DifyPlugin[Dify Plugin Tool<br/>工具入口]
    
    DifyPlugin --> FileValidation[文件验证<br/>大小/格式/行数列数]
    
    FileValidation -->|验证通过| FileDownload[从Dify获取文件内容]
    FileValidation -->|验证失败| Error1[返回错误信息]
    
    FileDownload --> ThreadMgr[会话管理<br/>获取或创建thread_id]
    
    ThreadMgr --> ExcelProcess[Excel文件处理<br/>excel_processor.py]
    
    ExcelProcess --> HeaderAnalysis[表头分析<br/>规则分析 + LLM验证可选]
    
    HeaderAnalysis --> CSVConvert[转换为CSV<br/>处理多级表头]
    
    CSVConvert --> AnalyzerSelect{选择分析器类型}
    
    AnalyzerSelect -->|langgraph| LangGraphFlow[LangGraph智能体工作流]
    AnalyzerSelect -->|legacy| LegacyFlow[Legacy分析器<br/>旧版工作流]
    
    LangGraphFlow --> Result[返回分析结果]
    LegacyFlow --> Result
    
    Result --> StreamOutput[流式输出<br/>实时返回给用户]
    
    StreamOutput --> End([完成])
    
    style DifyPlugin fill:#e1f5ff
    style LangGraphFlow fill:#fff4e1
    style LegacyFlow fill:#ffe1e1
    style Result fill:#e1ffe1
```

## 2. LangGraph 智能体详细工作流程

```mermaid
graph TB
    Start([开始分析]) --> InitState[初始化状态<br/>创建AnalysisState]
    
    InitState --> IntentNode[意图分析节点<br/>analyze_intent_node]
    
    IntentNode --> IntentCheck{理解用户需求<br/>制定分析计划}
    
    IntentCheck -->|需要澄清| Clarification[返回澄清请求<br/>USER_CLARIFICATION_NEEDED]
    IntentCheck -->|可以分析| CodeGen[代码生成节点<br/>generate_code_node]
    
    Clarification --> End1([结束])
    
    CodeGen --> CodeCheck{是否生成代码?}
    
    CodeCheck -->|无代码| ReportGen1[报告生成节点]
    CodeCheck -->|有代码| CodeExec[代码执行节点<br/>execute_code_node]
    
    CodeExec --> ExecCheck{执行结果}
    
    ExecCheck -->|执行成功| EvalNode[分析完整性评估节点<br/>evaluate_completeness_node]
    ExecCheck -->|执行失败| FixNode[代码修复节点<br/>fix_code_node]
    
    FixNode --> FixCheck{修复结果}
    
    FixCheck -->|修复成功| CodeExec
    FixCheck -->|无法修复| ReportGen2[报告生成节点]
    FixCheck -->|超过最大重试| ReportGen2
    
    EvalNode --> EvalCheck{评估结果}
    
    EvalCheck -->|需要更多分析<br/>且未达最大轮数| RoundCheck{检查轮次}
    EvalCheck -->|分析已完成<br/>或达到最大轮数| ReportGen3[报告生成节点<br/>generate_report_node]
    
    RoundCheck -->|继续分析| CodeGen
    RoundCheck -->|达到最大轮数| ReportGen3
    
    ReportGen1 --> End2([完成])
    ReportGen2 --> End2
    ReportGen3 --> End2
    
    style IntentNode fill:#e1f5ff
    style CodeGen fill:#fff4e1
    style CodeExec fill:#ffe1e1
    style FixNode fill:#ffe1f5
    style EvalNode fill:#e1ffe1
    style ReportGen3 fill:#e1ffe1
```

## 3. LangGraph 节点详细说明

### 3.1 意图分析节点 (analyze_intent_node)

**职责**：理解用户需求，制定分析计划

**输入**：
- CSV文件路径
- 数据预览
- 列名和元数据
- 用户查询

**处理**：
1. 调用LLM分析用户意图
2. 判断是否需要澄清
3. 确定分析类型（simple/overview/specific）
4. 生成分析任务列表

**输出**：
- 分析计划
- 首个分析任务
- 或澄清请求

### 3.2 代码生成节点 (generate_code_node)

**职责**：根据分析任务生成Python代码

**输入**：
- 当前分析任务
- 数据信息
- 之前的分析结果（多轮分析时）

**处理**：
1. 构建代码生成Prompt
2. 调用LLM生成代码
3. 从响应中提取Python代码块

**输出**：
- Python代码
- 或直接进入报告生成（无代码时）

### 3.3 代码执行节点 (execute_code_node)

**职责**：在安全环境中执行生成的代码

**输入**：
- Python代码
- 工作空间目录

**处理**：
1. 添加matplotlib中文支持
2. 在隔离环境中执行代码
3. 捕获执行输出和错误
4. 检测生成的文件

**输出**：
- 执行结果（成功/失败）
- 执行输出内容
- 错误信息（如有）

### 3.4 代码修复节点 (fix_code_node)

**职责**：当代码执行失败时，调用LLM修复代码

**输入**：
- 原始代码
- 错误信息
- 重试次数

**处理**：
1. 构建修复Prompt（包含错误信息）
2. 调用LLM生成修复后的代码
3. 提取修复后的代码

**输出**：
- 修复后的代码（返回执行节点）
- 或无法修复（进入报告生成）

**限制**：最大重试3次

### 3.5 分析完整性评估节点 (evaluate_completeness_node)

**职责**：评估当前分析是否充分回答了用户问题

**输入**：
- 用户原始查询
- 当前分析结果
- 已完成的任务
- 当前轮次

**处理**：
1. 调用LLM评估分析完整性
2. 判断是否需要更多分析
3. 如果需要，生成下一轮分析方向

**输出**：
- 需要更多分析 → 返回代码生成节点（循环）
- 分析已完成 → 进入报告生成

**限制**：默认最大3轮分析

### 3.6 报告生成节点 (generate_report_node)

**职责**：综合所有分析结果，生成最终报告

**输入**：
- 所有轮次的分析结果
- 用户原始查询
- 分析类型

**处理**：
1. 整合所有分析结果
2. 调用LLM生成综合报告
3. 格式化输出

**输出**：
- 最终分析报告
- 完成状态

## 4. 状态流转图

```mermaid
stateDiagram-v2
    [*] --> INIT: 初始化
    
    INIT --> INTENT_ANALYSIS: 开始分析
    
    INTENT_ANALYSIS --> CODE_GENERATION: 可以分析
    INTENT_ANALYSIS --> USER_CLARIFICATION_NEEDED: 需要澄清
    USER_CLARIFICATION_NEEDED --> [*]: 结束
    
    CODE_GENERATION --> CODE_EXECUTION: 生成代码
    CODE_GENERATION --> REPORT_GENERATION: 无代码
    
    CODE_EXECUTION --> EVALUATE_COMPLETENESS: 执行成功
    CODE_EXECUTION --> ERROR_FIXING: 执行失败
    
    ERROR_FIXING --> CODE_EXECUTION: 修复成功
    ERROR_FIXING --> REPORT_GENERATION: 无法修复
    
    EVALUATE_COMPLETENESS --> CODE_GENERATION: 需要更多分析
    EVALUATE_COMPLETENESS --> REPORT_GENERATION: 分析完成
    
    REPORT_GENERATION --> COMPLETED: 生成报告
    COMPLETED --> [*]: 结束
```

## 5. 数据流图

```mermaid
graph LR
    Excel[Excel文件] --> Processor[Excel处理器]
    
    Processor --> CSV[CSV文件]
    Processor --> Metadata[元数据文件]
    
    CSV --> State[AnalysisState<br/>状态对象]
    Metadata --> State
    
    State --> Intent[意图分析]
    Intent --> State
    
    State --> CodeGen[代码生成]
    CodeGen --> Code[Python代码]
    
    Code --> Exec[代码执行]
    Exec --> Output[执行输出]
    
    Output --> Eval[完整性评估]
    Eval -->|需要更多| CodeGen
    Eval -->|完成| Report[报告生成]
    
    Report --> Final[最终报告]
    
    style State fill:#e1f5ff
    style Code fill:#fff4e1
    style Output fill:#ffe1e1
    style Final fill:#e1ffe1
```

## 6. 多轮分析循环机制

```mermaid
sequenceDiagram
    participant User as 用户
    participant Tool as Dify Tool
    participant Graph as LangGraph
    participant LLM as LLM API
    participant Exec as 代码执行器
    
    User->>Tool: 上传文件 + 查询
    Tool->>Graph: 启动分析工作流
    
    Graph->>LLM: 意图分析
    LLM-->>Graph: 分析计划
    
    loop 多轮分析 (最多3轮)
        Graph->>LLM: 生成代码
        LLM-->>Graph: Python代码
        Graph->>Exec: 执行代码
        Exec-->>Graph: 执行结果
        
        alt 执行成功
            Graph->>LLM: 评估分析完整性
            LLM-->>Graph: 评估结果
            
            alt 需要更多分析
                Graph->>LLM: 生成下一轮代码
                Note over Graph: 继续循环
            else 分析完成
                Graph->>LLM: 生成最终报告
                LLM-->>Graph: 最终报告
            end
        else 执行失败
            Graph->>LLM: 修复代码
            LLM-->>Graph: 修复后的代码
            Graph->>Exec: 重新执行
        end
    end
    
    Graph-->>Tool: 流式输出结果
    Tool-->>User: 实时返回分析过程
```

## 7. 流式输出机制

```mermaid
graph TB
    Start([开始分析]) --> CreateQueue[为请求创建独立队列<br/>request_id]
    
    CreateQueue --> Thread[启动后台线程<br/>执行LangGraph工作流]
    
    Thread --> NodeExec[节点执行]
    
    NodeExec --> LLMCall[调用LLM<br/>流式模式]
    
    LLMCall --> TokenStream[实时接收Token]
    
    TokenStream --> PushQueue[推送到请求队列<br/>_push_to_request_queue]
    
    PushQueue --> MainThread[主线程从队列读取]
    
    MainThread --> Yield[Yield给调用方<br/>实时输出]
    
    Yield --> CheckEnd{工作流完成?}
    
    CheckEnd -->|未完成| NodeExec
    CheckEnd -->|完成| SendEnd[发送结束标记<br/>None]
    
    SendEnd --> Cleanup[清理队列]
    Cleanup --> End([结束])
    
    style CreateQueue fill:#e1f5ff
    style Thread fill:#fff4e1
    style TokenStream fill:#ffe1e1
    style Yield fill:#e1ffe1
```

## 8. 关键技术点

### 8.1 多线程安全
- 每个请求使用独立的队列（`request_id`）
- 使用线程锁保护共享资源
- 后台线程执行工作流，主线程处理流式输出

### 8.2 状态管理
- 使用 `TypedDict` 定义状态结构
- 使用 `Annotated` 实现列表追加
- 状态在节点间自动传递和更新

### 8.3 错误处理
- 代码执行失败 → 自动修复（最多3次）
- 无法修复 → 生成报告（包含错误信息）
- 超时保护 → 默认360秒超时

### 8.4 多轮分析
- 自动评估分析完整性
- 支持最多3轮分析（可配置）
- 每轮分析基于前一轮结果

### 8.5 流式输出
- LLM响应实时传递
- 支持打字机效果
- 节点完成信息实时反馈

## 9. 配置参数

### 9.1 必选配置
- `analysis_api_url`: 数据分析API地址
- `analysis_model`: 分析模型名称

### 9.2 可选配置
- `llm_api_key`: LLM API密钥（用于表头验证）
- `llm_base_url`: LLM Base URL
- `llm_model`: LLM模型名称
- `analyzer_type`: 分析器类型（langgraph/legacy）
- `max_analysis_rounds`: 最大分析轮数（默认3）
- `analysis_timeout`: 分析超时时间（默认360秒）
- `debug_print_execution_output`: 是否打印执行结果

## 10. 文件结构说明

```
dify-plugin-data-analyzer-langgrpah/
├── main.py                          # 插件入口
├── tools/
│   └── dify-plugin-data-analyzer.py # Dify工具实现
├── provider/
│   └── dify-plugin-data-analyzer.py # 提供者实现
├── core/
│   ├── excel_analyze_api.py         # 核心API（入口）
│   ├── excel_processor.py          # Excel文件处理
│   ├── analyzer/
│   │   ├── graph.py                 # LangGraph工作流图
│   │   ├── state.py                 # 状态定义
│   │   └── prompts.py               # 提示词模板
│   ├── storage.py                   # 存储管理
│   └── utils.py                     # 工具函数
└── workspace/                        # 工作空间（文件存储）
```

